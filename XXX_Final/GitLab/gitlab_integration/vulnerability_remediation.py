"""
Vulnerability Remediation Module
Provides specific fix suggestions for detected security vulnerabilities
"""

import re
import ast
from typing import List, Dict, Tuple, Any, Optional
from dataclasses import dataclass

@dataclass
class RemediationSuggestion:
    """Represents a remediation suggestion for a vulnerability"""
    vulnerability_type: str
    severity: str
    description: str
    vulnerable_code: str
    fixed_code: str
    explanation: str
    best_practices: List[str]
    additional_resources: List[str]

class VulnerabilityRemediator:
    """
    Provides specific remediation suggestions for security vulnerabilities
    """
    
    def __init__(self):
        self.remediation_patterns = {
            'sql_injection': {
                'patterns': [
                    r'SELECT.*\+.*["\']',
                    r'INSERT.*\+.*["\']',
                    r'UPDATE.*\+.*["\']',
                    r'DELETE.*\+.*["\']',
                    r'executeQuery\s*\([^)]*\+',
                    r'execute\s*\([^)]*\+'
                ],
                'sources': [
                    r'request\.getParameter',
                    r'request\.getHeader',
                    r'request\.getAttribute',
                    r'$_GET',
                    r'$_POST',
                    r'$_COOKIE',
                    r'input\s*\(',
                    r'raw_input\s*\('
                ]
            },
            'xss': {
                'patterns': [
                    r'innerHTML\s*=',
                    r'outerHTML\s*=',
                    r'document\.write\s*\(',
                    r'Response\.Write\s*\(',
                    r'echo\s+[^;]*\+',
                    r'print\s+[^;]*\+'
                ],
                'sources': [
                    r'request\.getParameter',
                    r'request\.getHeader',
                    r'$_GET',
                    r'$_POST',
                    r'$_COOKIE',
                    r'input\s*\(',
                    r'raw_input\s*\('
                ]
            },
            'command_injection': {
                'patterns': [
                    r'os\.system\s*\(',
                    r'subprocess\.(run|call|Popen)\s*\(',
                    r'exec\s*\(',
                    r'eval\s*\(',
                    r'Runtime\.getRuntime\(\)\.exec\s*\(',
                    r'Process\.Start\s*\('
                ],
                'sources': [
                    r'request\.getParameter',
                    r'request\.getHeader',
                    r'$_GET',
                    r'$_POST',
                    r'$_COOKIE',
                    r'input\s*\(',
                    r'raw_input\s*\('
                ]
            },
            'path_traversal': {
                'patterns': [
                    r'open\s*\([^)]*\+',
                    r'file\s*\([^)]*\+',
                    r'fopen\s*\([^)]*\+',
                    r'File\.Open\s*\([^)]*\+',
                    r'include\s*\([^)]*\+',
                    r'require\s*\([^)]*\+'
                ],
                'sources': [
                    r'request\.getParameter',
                    r'request\.getHeader',
                    r'$_GET',
                    r'$_POST',
                    r'$_COOKIE',
                    r'input\s*\(',
                    r'raw_input\s*\('
                ]
            }
        }
        
        self.language_templates = {
            'java': {
                'sql_injection': {
                    'prepared_statement': 'PreparedStatement stmt = conn.prepareStatement("SELECT * FROM users WHERE id = ?");\nstmt.setString(1, userId);\nResultSet rs = stmt.executeQuery();',
                    'parameterized_query': 'String query = "SELECT * FROM users WHERE id = ?";\nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, userId);'
                },
                'xss': {
                    'escape_html': 'String safeOutput = StringEscapeUtils.escapeHtml(userInput);\nresponse.getWriter().write(safeOutput);',
                    'jsp_escape': '<%= StringEscapeUtils.escapeHtml(userInput) %>'
                }
            },
            'python': {
                'sql_injection': {
                    'parameterized_query': 'cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))',
                    'orm_query': 'User.objects.filter(id=user_id)'
                },
                'xss': {
                    'escape_html': 'from html import escape\nsafe_output = escape(user_input)',
                    'jinja_escape': '{{ user_input | e }}'
                },
                'command_injection': {
                    'subprocess_safe': 'import subprocess\nresult = subprocess.run([\'ls\', \'-la\'], capture_output=True, text=True)',
                    'shlex_quote': 'import shlex\nsafe_command = shlex.quote(user_input)'
                }
            },
            'php': {
                'sql_injection': {
                    'prepared_statement': '$stmt = $pdo->prepare("SELECT * FROM users WHERE id = ?");\n$stmt->execute([$userId]);',
                    'parameterized_query': '$stmt = $pdo->prepare("SELECT * FROM users WHERE id = :id");\n$stmt->bindParam(\':id\', $userId);\n$stmt->execute();'
                },
                'xss': {
                    'escape_html': 'echo htmlspecialchars($userInput, ENT_QUOTES, \'UTF-8\');',
                    'filter_var': 'echo filter_var($userInput, FILTER_SANITIZE_STRING);'
                }
            },
            'csharp': {
                'sql_injection': {
                    'parameterized_query': 'using (SqlCommand cmd = new SqlCommand("SELECT * FROM users WHERE id = @id", connection))\n{\n    cmd.Parameters.AddWithValue("@id", userId);\n    // Execute command\n}',
                    'entity_framework': 'var users = context.Users.Where(u => u.Id == userId).ToList();'
                },
                'xss': {
                    'html_encode': 'string safeOutput = HttpUtility.HtmlEncode(userInput);\nResponse.Write(safeOutput);',
                    'razor_escape': '@Html.Raw(HttpUtility.HtmlEncode(userInput))'
                }
            }
        }

    def detect_vulnerability_type(self, code: str) -> Optional[str]:
        """Detect the type of vulnerability in the code"""
        code_lower = code.lower()
        
        for vuln_type, patterns in self.remediation_patterns.items():
            for pattern in patterns['patterns']:
                if re.search(pattern, code, re.IGNORECASE):
                    return vuln_type
        
        return None

    def detect_language(self, code: str) -> str:
        """Detect the programming language of the code"""
        if 'import java' in code or 'public class' in code or 'System.out' in code:
            return 'java'
        elif 'import ' in code and ('def ' in code or 'print(' in code):
            return 'python'
        elif '<?php' in code or '$_' in code or 'echo ' in code:
            return 'php'
        elif 'using System' in code or 'public class' in code or 'Console.WriteLine' in code:
            return 'csharp'
        elif '<script' in code or 'document.' in code or 'function ' in code:
            return 'javascript'
        else:
            return 'unknown'

    def generate_remediation(self, code: str, vulnerability_type: str = None) -> Optional[RemediationSuggestion]:
        """Generate remediation suggestion for a vulnerable code snippet"""
        
        # Detect vulnerability type if not provided
        if not vulnerability_type:
            vulnerability_type = self.detect_vulnerability_type(code)
        
        if not vulnerability_type:
            return None
        
        # Detect language
        language = self.detect_language(code)
        
        # Generate remediation based on type and language
        if vulnerability_type == 'sql_injection':
            return self._remediate_sql_injection(code, language)
        elif vulnerability_type == 'xss':
            return self._remediate_xss(code, language)
        elif vulnerability_type == 'command_injection':
            return self._remediate_command_injection(code, language)
        elif vulnerability_type == 'path_traversal':
            return self._remediate_path_traversal(code, language)
        else:
            return self._remediate_generic(code, vulnerability_type, language)

    def _remediate_sql_injection(self, code: str, language: str) -> RemediationSuggestion:
        """Generate SQL injection remediation"""
        
        if language == 'java':
            fixed_code = self._fix_java_sql_injection(code)
            explanation = "Use PreparedStatement with parameterized queries instead of string concatenation"
            best_practices = [
                "Always use PreparedStatement for dynamic SQL queries",
                "Never concatenate user input directly into SQL strings",
                "Use parameterized queries with ? placeholders",
                "Validate and sanitize input before using in queries"
            ]
        elif language == 'python':
            fixed_code = self._fix_python_sql_injection(code)
            explanation = "Use parameterized queries with %s placeholders instead of string concatenation"
            best_practices = [
                "Use parameterized queries with %s placeholders",
                "Use ORM frameworks like Django ORM or SQLAlchemy",
                "Never use string formatting for SQL queries",
                "Validate input before database operations"
            ]
        elif language == 'php':
            fixed_code = self._fix_php_sql_injection(code)
            explanation = "Use prepared statements with PDO or MySQLi instead of string concatenation"
            best_practices = [
                "Use PDO with prepared statements",
                "Use parameterized queries with :name or ? placeholders",
                "Never concatenate user input into SQL strings",
                "Use proper input validation and sanitization"
            ]
        elif language == 'csharp':
            fixed_code = self._fix_csharp_sql_injection(code)
            explanation = "Use parameterized queries with @parameter placeholders instead of string concatenation"
            best_practices = [
                "Use SqlCommand with parameters",
                "Use Entity Framework for database operations",
                "Never concatenate user input into SQL strings",
                "Use proper input validation"
            ]
        else:
            fixed_code = self._fix_generic_sql_injection(code)
            explanation = "Use parameterized queries instead of string concatenation"
            best_practices = [
                "Use parameterized queries",
                "Never concatenate user input into SQL strings",
                "Validate and sanitize all input",
                "Use prepared statements"
            ]
        
        return RemediationSuggestion(
            vulnerability_type="SQL Injection",
            severity="High",
            description="User input is directly concatenated into SQL query, allowing SQL injection attacks",
            vulnerable_code=code,
            fixed_code=fixed_code,
            explanation=explanation,
            best_practices=best_practices,
            additional_resources=[
                "OWASP SQL Injection Prevention Cheat Sheet",
                "CWE-89: Improper Neutralization of Special Elements used in an SQL Command",
                "NIST Guidelines for SQL Injection Prevention"
            ]
        )

    def _remediate_xss(self, code: str, language: str) -> RemediationSuggestion:
        """Generate XSS remediation"""
        
        if language == 'java':
            fixed_code = self._fix_java_xss(code)
            explanation = "Escape HTML entities before outputting user input to prevent XSS attacks"
            best_practices = [
                "Always escape HTML entities before output",
                "Use Content Security Policy (CSP) headers",
                "Validate and sanitize all user input",
                "Use context-appropriate encoding"
            ]
        elif language == 'python':
            fixed_code = self._fix_python_xss(code)
            explanation = "Escape HTML entities before outputting user input to prevent XSS attacks"
            best_practices = [
                "Use html.escape() for HTML output",
                "Use Jinja2 auto-escaping in templates",
                "Validate and sanitize all user input",
                "Implement Content Security Policy"
            ]
        elif language == 'php':
            fixed_code = self._fix_php_xss(code)
            explanation = "Escape HTML entities before outputting user input to prevent XSS attacks"
            best_practices = [
                "Use htmlspecialchars() for HTML output",
                "Use filter_var() for input sanitization",
                "Validate and sanitize all user input",
                "Implement Content Security Policy"
            ]
        elif language == 'csharp':
            fixed_code = self._fix_csharp_xss(code)
            explanation = "Encode HTML entities before outputting user input to prevent XSS attacks"
            best_practices = [
                "Use HttpUtility.HtmlEncode() for HTML output",
                "Use Razor auto-escaping in views",
                "Validate and sanitize all user input",
                "Implement Content Security Policy"
            ]
        else:
            fixed_code = self._fix_generic_xss(code)
            explanation = "Escape HTML entities before outputting user input to prevent XSS attacks"
            best_practices = [
                "Escape HTML entities before output",
                "Validate and sanitize all user input",
                "Implement Content Security Policy",
                "Use context-appropriate encoding"
            ]
        
        return RemediationSuggestion(
            vulnerability_type="Cross-Site Scripting (XSS)",
            severity="Medium",
            description="User input is directly output to HTML without proper escaping, allowing XSS attacks",
            vulnerable_code=code,
            fixed_code=fixed_code,
            explanation=explanation,
            best_practices=best_practices,
            additional_resources=[
                "OWASP XSS Prevention Cheat Sheet",
                "CWE-79: Improper Neutralization of Input During Web Page Generation",
                "OWASP Content Security Policy Cheat Sheet"
            ]
        )

    def _remediate_command_injection(self, code: str, language: str) -> RemediationSuggestion:
        """Generate command injection remediation"""
        
        if language == 'python':
            fixed_code = self._fix_python_command_injection(code)
            explanation = "Use subprocess with list arguments instead of shell commands to prevent command injection"
            best_practices = [
                "Use subprocess.run() with list arguments",
                "Never use shell=True with user input",
                "Use shlex.quote() if shell commands are necessary",
                "Validate and sanitize all command input"
            ]
        elif language == 'java':
            fixed_code = self._fix_java_command_injection(code)
            explanation = "Avoid using Runtime.exec() with user input, use ProcessBuilder with validated arguments"
            best_practices = [
                "Use ProcessBuilder instead of Runtime.exec()",
                "Validate and sanitize all command arguments",
                "Use whitelist of allowed commands",
                "Avoid shell command execution with user input"
            ]
        else:
            fixed_code = self._fix_generic_command_injection(code)
            explanation = "Avoid executing shell commands with user input to prevent command injection"
            best_practices = [
                "Avoid shell command execution with user input",
                "Use whitelist of allowed commands",
                "Validate and sanitize all command arguments",
                "Use safer alternatives when possible"
            ]
        
        return RemediationSuggestion(
            vulnerability_type="Command Injection",
            severity="High",
            description="User input is directly used in shell commands, allowing command injection attacks",
            vulnerable_code=code,
            fixed_code=fixed_code,
            explanation=explanation,
            best_practices=best_practices,
            additional_resources=[
                "OWASP Command Injection Prevention",
                "CWE-78: Improper Neutralization of Special Elements used in an OS Command",
                "NIST Guidelines for Command Injection Prevention"
            ]
        )

    def _remediate_path_traversal(self, code: str, language: str) -> RemediationSuggestion:
        """Generate path traversal remediation"""
        
        if language == 'python':
            fixed_code = self._fix_python_path_traversal(code)
            explanation = "Use os.path.basename() to prevent directory traversal attacks"
            best_practices = [
                "Use os.path.basename() to get only the filename",
                "Validate file paths against whitelist",
                "Use absolute paths and check they're within allowed directory",
                "Never use user input directly in file operations"
            ]
        elif language == 'java':
            fixed_code = self._fix_java_path_traversal(code)
            explanation = "Use Path.getFileName() and validate paths to prevent directory traversal attacks"
            best_practices = [
                "Use Path.getFileName() to get only the filename",
                "Validate file paths against whitelist",
                "Use absolute paths and check they're within allowed directory",
                "Never use user input directly in file operations"
            ]
        else:
            fixed_code = self._fix_generic_path_traversal(code)
            explanation = "Validate and sanitize file paths to prevent directory traversal attacks"
            best_practices = [
                "Extract only the filename from user input",
                "Validate file paths against whitelist",
                "Use absolute paths and check they're within allowed directory",
                "Never use user input directly in file operations"
            ]
        
        return RemediationSuggestion(
            vulnerability_type="Path Traversal",
            severity="Medium",
            description="User input is used directly in file operations, allowing directory traversal attacks",
            vulnerable_code=code,
            fixed_code=fixed_code,
            explanation=explanation,
            best_practices=best_practices,
            additional_resources=[
                "OWASP Path Traversal Prevention",
                "CWE-22: Improper Limitation of a Pathname to a Restricted Directory",
                "NIST Guidelines for Path Traversal Prevention"
            ]
        )

    def _remediate_generic(self, code: str, vulnerability_type: str, language: str) -> RemediationSuggestion:
        """Generate generic remediation for unknown vulnerability types"""
        
        return RemediationSuggestion(
            vulnerability_type=vulnerability_type.title(),
            severity="Unknown",
            description=f"Potential {vulnerability_type} vulnerability detected",
            vulnerable_code=code,
            fixed_code="// TODO: Implement proper security measures\n// Validate and sanitize all user input\n// Use secure coding practices",
            explanation="Review the code and implement appropriate security measures",
            best_practices=[
                "Validate and sanitize all user input",
                "Use secure coding practices",
                "Follow OWASP guidelines",
                "Implement proper error handling"
            ],
            additional_resources=[
                "OWASP Top 10",
                "CWE/SANS Top 25 Most Dangerous Software Errors",
                "Secure Coding Guidelines"
            ]
        )

    # Language-specific fix methods
    def _fix_java_sql_injection(self, code: str) -> str:
        """Fix Java SQL injection"""
        if 'String query =' in code and '+' in code:
            return code.replace(
                'String query = "SELECT * FROM users WHERE id = \'" + userInput + "\'";',
                'String query = "SELECT * FROM users WHERE id = ?";\nPreparedStatement stmt = conn.prepareStatement(query);\nstmt.setString(1, userInput);'
            )
        return "// Use PreparedStatement with parameterized queries\nPreparedStatement stmt = conn.prepareStatement(\"SELECT * FROM users WHERE id = ?\");\nstmt.setString(1, userInput);\nResultSet rs = stmt.executeQuery();"

    def _fix_python_sql_injection(self, code: str) -> str:
        """Fix Python SQL injection"""
        if 'execute(' in code and '%' in code:
            return code.replace(
                'cursor.execute("SELECT * FROM users WHERE id = \'" + user_id + "\'")',
                'cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))'
            )
        return "# Use parameterized queries\ncursor.execute(\"SELECT * FROM users WHERE id = %s\", (user_id,))"

    def _fix_php_sql_injection(self, code: str) -> str:
        """Fix PHP SQL injection"""
        if 'query(' in code and '$' in code:
            return code.replace(
                'mysql_query("SELECT * FROM users WHERE id = \'" . $userId . "\'")',
                '$stmt = $pdo->prepare("SELECT * FROM users WHERE id = ?");\n$stmt->execute([$userId]);'
            )
        return "// Use prepared statements\n$stmt = $pdo->prepare(\"SELECT * FROM users WHERE id = ?\");\n$stmt->execute([$userId]);"

    def _fix_csharp_sql_injection(self, code: str) -> str:
        """Fix C# SQL injection"""
        if 'Command(' in code and '+' in code:
            return code.replace(
                'new SqlCommand("SELECT * FROM users WHERE id = \'" + userId + "\'")',
                'new SqlCommand("SELECT * FROM users WHERE id = @id")\ncmd.Parameters.AddWithValue("@id", userId);'
            )
        return "// Use parameterized queries\nusing (SqlCommand cmd = new SqlCommand(\"SELECT * FROM users WHERE id = @id\", connection))\n{\n    cmd.Parameters.AddWithValue(\"@id\", userId);\n}"

    def _fix_java_xss(self, code: str) -> str:
        """Fix Java XSS"""
        if 'innerHTML' in code or 'document.write' in code:
            return code.replace(
                'document.write(userInput)',
                'document.write(escapeHtml(userInput))'
            )
        return "// Escape HTML entities\nString safeOutput = StringEscapeUtils.escapeHtml(userInput);\nresponse.getWriter().write(safeOutput);"

    def _fix_python_xss(self, code: str) -> str:
        """Fix Python XSS"""
        if 'print(' in code and '+' in code:
            return code.replace(
                'print(user_input)',
                'from html import escape\nprint(escape(user_input))'
            )
        return "# Escape HTML entities\nfrom html import escape\nsafe_output = escape(user_input)\nprint(safe_output)"

    def _fix_php_xss(self, code: str) -> str:
        """Fix PHP XSS"""
        if 'echo' in code and '$' in code:
            return code.replace(
                'echo $userInput;',
                'echo htmlspecialchars($userInput, ENT_QUOTES, \'UTF-8\');'
            )
        return "// Escape HTML entities\necho htmlspecialchars($userInput, ENT_QUOTES, 'UTF-8');"

    def _fix_csharp_xss(self, code: str) -> str:
        """Fix C# XSS"""
        if 'Response.Write' in code:
            return code.replace(
                'Response.Write(userInput)',
                'Response.Write(HttpUtility.HtmlEncode(userInput))'
            )
        return "// Encode HTML entities\nResponse.Write(HttpUtility.HtmlEncode(userInput));"

    def _fix_python_command_injection(self, code: str) -> str:
        """Fix Python command injection"""
        if 'os.system(' in code:
            return code.replace(
                'os.system(command)',
                'import subprocess\nsubprocess.run([command], shell=False)'
            )
        return "# Use subprocess safely\nimport subprocess\nsubprocess.run([\'ls\', \'-la\'], capture_output=True, text=True)"

    def _fix_java_command_injection(self, code: str) -> str:
        """Fix Java command injection"""
        if 'Runtime.getRuntime().exec(' in code:
            return code.replace(
                'Runtime.getRuntime().exec(command)',
                'ProcessBuilder pb = new ProcessBuilder(command.split(" "));\nProcess p = pb.start();'
            )
        return "// Use ProcessBuilder instead of Runtime.exec()\nProcessBuilder pb = new ProcessBuilder(\"ls\", \"-la\");\nProcess p = pb.start();"

    def _fix_python_path_traversal(self, code: str) -> str:
        """Fix Python path traversal"""
        if 'open(' in code and '+' in code:
            return code.replace(
                'open(filename)',
                'import os\nsafe_filename = os.path.basename(filename)\nopen(safe_filename)'
            )
        return "# Use os.path.basename() to prevent path traversal\nimport os\nsafe_filename = os.path.basename(filename)\nopen(safe_filename)"

    def _fix_java_path_traversal(self, code: str) -> str:
        """Fix Java path traversal"""
        if 'File(' in code and '+' in code:
            return code.replace(
                'new File(filename)',
                'Path path = Paths.get(filename);\nString safeFilename = path.getFileName().toString();\nnew File(safeFilename)'
            )
        return "// Use Path.getFileName() to prevent path traversal\nPath path = Paths.get(filename);\nString safeFilename = path.getFileName().toString();\nnew File(safeFilename)"

    def _fix_generic_sql_injection(self, code: str) -> str:
        """Generic SQL injection fix"""
        return "// Use parameterized queries instead of string concatenation\n// Example: SELECT * FROM users WHERE id = ?\n// Then bind the parameter safely"

    def _fix_generic_xss(self, code: str) -> str:
        """Generic XSS fix"""
        return "// Escape HTML entities before output\n// Example: escapeHtml(userInput) or htmlspecialchars(userInput)"

    def _fix_generic_command_injection(self, code: str) -> str:
        """Generic command injection fix"""
        return "// Avoid executing shell commands with user input\n// Use whitelist of allowed commands or safer alternatives"

    def _fix_generic_path_traversal(self, code: str) -> str:
        """Generic path traversal fix"""
        return "// Extract only filename from user input\n// Validate paths against whitelist\n// Use absolute paths within allowed directory"

    def generate_remediation_report(self, code: str, vulnerability_type: str = None) -> str:
        """Generate a comprehensive remediation report"""
        remediation = self.generate_remediation(code, vulnerability_type)
        
        if not remediation:
            return "No specific vulnerability detected or remediation available."
        
        report = f"""
VULNERABILITY REMEDIATION REPORT
================================

Vulnerability Type: {remediation.vulnerability_type}
Severity: {remediation.severity}

DESCRIPTION:
{remediation.description}

VULNERABLE CODE:
{remediation.vulnerable_code}

FIXED CODE:
{remediation.fixed_code}

EXPLANATION:
{remediation.explanation}

BEST PRACTICES:
"""
        for i, practice in enumerate(remediation.best_practices, 1):
            report += f"{i}. {practice}\n"
        
        report += "\nADDITIONAL RESOURCES:\n"
        for resource in remediation.additional_resources:
            report += f"- {resource}\n"
        
        return report


def test_remediation():
    """Test the remediation functionality"""
    remediator = VulnerabilityRemediator()
    
    test_cases = [
        "SELECT * FROM users WHERE id = '" + "user_input" + "'",
        "document.write('<script>alert(1)</script>')",
        "os.system('rm -rf /')",
        "open('/etc/passwd')"
    ]
    
    for code in test_cases:
        print(f"\n{'='*60}")
        print(f"Testing: {code}")
        print('='*60)
        
        remediation = remediator.generate_remediation(code)
        if remediation:
            print(f"Vulnerability: {remediation.vulnerability_type}")
            print(f"Severity: {remediation.severity}")
            print(f"Fixed Code:\n{remediation.fixed_code}")
        else:
            print("No vulnerability detected")


if __name__ == "__main__":
    test_remediation()
